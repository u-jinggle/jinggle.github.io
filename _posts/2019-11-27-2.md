---
published: true
layout: single
title: "버그? 원인은? Ruby on Rails를 Debugging 해보자"
category: post
comments: true
---

최근 Ruby on Rails를 통해 처음 개발을 진행해 보며, Error가 나긴 하는데 대체 어디서 나는 건지 답답함을 느끼기 시작했습니다.
Error를 시원하게 찾기위해 Ruby의 Debuggig 방법에 대해 찾아 보았습니다!

## raise Method
개발자들이 가장 먼저, 가장 빠르게 원인을 찾기위해서는 별도의 Debuggig 툴을 사용할 것 없이 Ruby에서 제공해 주는 raise 메소드를 이용할 수 있습니다.
#### raise란?
인수로 지정한 문자열을 메시지로 해서 RuntimeError를 발생시키는 메소드입니다.
첫 인수로 예외 클래스를 지정할 경우, 두번째 인수로 메시지를 지정합니다.
inspect Method를 사용해 문자열로 반환된 값을 확인 해 볼 수 있습니다.
{% highlight ruby %}
  def index
    @products = Product.all
    raise @products.inspect
    @test = Product.all
  end
{% endhighlight %}
![raise 예시 이미지](/assets/images/2-4.png){: width="70%"}

## web-consolegem
- 'console' 메서드를 루비 코드 내에서 호출 시 HTML컨텐츠 옆에 콘솔창을 렌더링 할 수 있습니다.
- 아래 이미지와 같이 Product 테이블의 정보를 @products와 @test에 넣어 web-console 창에서 호출해 보았을때, @test의 값도 정상적으로 출력되는 것을 볼때, console의 호출 순서는 상관 없다는 것을 알 수 있었습니다.
{% highlight ruby %}
  def index
    @products = Product.all
    console
    @test = Product.all
  end
{% endhighlight %}
![web-consolegem 예시 이미지](/assets/images/2-2.png){: width="70%"}
- 주의 : 한번에 2개 이상의 console 호출시 error가 발생 한다고 하니 한번만 호출하는게 좋겠습니다.

## RubyMine Debugger
#### RubyMine이란?
JetBrains사의 Ruby진영 개발 툴 입니다.
RubyMine에서 지원해 주는 Debug기능을 사용하면 보다 편리하게 Debugging을 진행할 수 있습니다.
> ### RubyMine Debugger 실행시키기
![RubyMine Debugger 예시 이미지](/assets/images/2-5.png){: width="100%"}
- 실행을 중단하여 확인해 보고 싶은 위치에 마우스 왼쪽 클릭하여 Break Point를 생성합니다.
- Debug Mode를 실행 시킬땐 ctrl+D(mac기준) 또는 상단의 벌레 모양 아이콘을 선택하여 실행 시킬 수 있습니다.

> ### RubyMine Debugger 실행시 UI 역할
![RubyMine Debugger 예시 이미지](/assets/images/2-6.png){: width="100%"}
- A : break line에 오기까지의 call stack을 확인 할 수 있습니다.
- B : 좌측 call stack line의 변수
- C : 좌측 call stack line의 watch

>![RubyMine Debugger 예시 이미지](/assets/images/2-7.png){: width="100%", :class=mfp-img}
- A : break line에 오기까지의 call stack을 확인 할 수 있습니다.
- B : 좌측 call stack line의 변수
- C : 좌측 call stack line의 watch

## byebug
#### byebug란?
실행을 멈추고 확인하고 싶은 위치에 'byebug' 메서드를 호출하여 실행 시점까지의 유효한 데이터를 확인해 볼 수 있습니다.
{% highlight ruby %}
def create
    @product = Product.new(product_params)
    byebug
    respond_to do |format|
      if @product.save
        format.html { redirect_to @product, notice: 'Product was successfully created.' }
        format.json { render :show, status: :created, location: @product }
      else
        format.html { render :new }
        format.json { render json: @product.errors, status: :unprocessable_entity }
      end
    end
  end
{% endhighlight %}
>![byebug 예시 이미지](/assets/images/2-8.png){: width="100%", :class=mfp-img}
>사용방법
- l- (or list-) : debug 실행 시작 시점에서 10줄 앞의 코드 확인 할 수 있습니다.
- l= (or list=) : debug 실행 시점으로 돌아갑니다.
- backtrace (or where) : break line에 오기까지의 call stack을 확인 할 수 있습니다.
- frame n : backtrace에서 확인한 call stack의 n번째로 debug실행 시점을 이동합니다.
-- up n / down n : backtrace에서 확인한 call stack을 n개씩 한번에 이동합니다.
- instance_variables : 현재 시점에서 사용하고 있는 인스턴스 변수 전체를 출력합니다.
- display 변수 : 변수값을 출력합니다.
- step :
- next :


