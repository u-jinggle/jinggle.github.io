---
published: true
layout: single
title: "버그? 원인은? Ruby on Rails를 Debugging 해보자"
category: post
comments: true
---

최근 Ruby on Rails를 통해 처음 개발을 진행해 보며, Error가 나긴 하는데 대체 어디서 나는 건지 답답함을 느끼기 시작했습니다.  
Error를 시원하게 찾기위해 Ruby의 Debuggig 방법에 대해 찾아 보았습니다!

## raise Method
개발자들이 가장 먼저, 가장 빠르게 원인을 찾기위해서는 별도의 Debuggig 툴을 사용할 것 없이 Ruby에서 제공해 주는 raise 메소드를 이용할 수 있습니다.
#### raise란? 
- 인수로 지정한 문자열을 메시지로 해서 RuntimeError를 발생시키는 메소드입니다.  
- inspect 메소드를 사용하여 출력하고 싶은 인스턴스 변수의 데이터를 확인 할 수 있습니다.  
- 또한 브라우저 상에 보여지는 web-console에서 raise 메소드 호출 이전 시점까지의 디버깅이 가능합니다.  

> #### 실행코드
{% highlight ruby %}
  def index
    @products = Product.all
    raise @products.inspect
    @test = Product.all
  end
{% endhighlight %}

> #### 결과이미지
![raise 예시 이미지](/assets/images/2-4.png){: width="100%"}  
이미지에서 처럼 raise이후에 선언된 @test 인스턴스 변수는 undefined 되고 있습니다. 

## web-consolegem
- 'console' 메서드를 루비 코드 내에서 호출 시 HTML컨텐츠 옆에 콘솔창을 렌더링 할 수 있습니다.
- 주의 : 한번에 2개 이상의 console 호출시 error가 발생 한다고 하니 한번만 호출하는게 좋겠습니다.

> #### 실행코드
{% highlight ruby %}
  def index
    @products = Product.all
    console
    @test = Product.all
  end
{% endhighlight %}

> #### 결과이미지
![web-consolegem 예시 이미지](/assets/images/2-2.png){: width="100%"}  
위의 이미지와 같이 Product 테이블의 정보를 @products와 @test에 넣어 web-console 창에서 호출해 보았을때, @test의 값도 정상적으로 출력되는 것을 볼때, console의 호출 순서는 상관 없다는 것을 알 수 있었습니다.  

## RubyMine Debugger
#### RubyMine이란?  
JetBrains사의 Ruby진영 개발 툴 입니다.  
RubyMine에서 지원해 주는 Debug기능을 사용하면 보다 편리하게 Debugging을 진행할 수 있습니다.
> ### RubyMine Debugger 실행시키기
![RubyMine Debugger 예시 이미지](/assets/images/2-5.png){: width="100%"}
- 실행을 중단하여 확인해 보고 싶은 위치에 마우스 왼쪽 클릭하여 Break Point를 생성합니다.  
- Debug Mode를 실행 시킬땐 ctrl+D(mac기준) 또는 상단의 벌레 모양 아이콘을 선택하여 실행 시킬 수 있습니다.  

> ### RubyMine Debugger 실행시 UI 역할
![RubyMine Debugger 예시 이미지](/assets/images/2-6.png){: width="100%"}
- A : break line에 오기까지의 call stack을 확인 할 수 있습니다.
- B : 좌측 call stack line의 변수
- C : 좌측 call stack line의 Watches  

>![RubyMine Debugger 예시 이미지](/assets/images/2-7.png){: width="100%", :class=mfp-img}
- A : **[Resume]** Break Point가 여러개일 경우 다음 Break Point로 이동됩니다.
- B : **[Step Over]** Break Point가 존재하는 파일내에서 Break Point 다음 라인으로 한줄씩 이동합니다. (F8)
- C : **[Step Into]** 현재 Break Point 라인에서 실행하는 실제 코드의 위치로 이동합니다. stepping 설정에 따라 debug조건이 달라집니다. (F7)
- D : **[Force Step Into]** 현재 Break Point 라인에서 실행하는 실제 코드의 위치로 이동합니다. stepping 설정과 무관하게 debeging 진행됩니다. (option+shift+F7)
##### Stepping이란?
command+shift+a -> stepping 창에서 debug 실행 조건 설정 가능
- F : **[Step Out]** call stack 창에 떠있는 stack을 하나씩 이전으로 이동합니다.
- G : **[Run To Cursor]** 마우스 커서가 위치하는 라인으로 Break Point가 이동됩니다.
- H : **[Evaluate]** Evaluate이 실행되며 확인하고 싶은 코드 디버깅이 가능합니다.
- I : **[New Watch]** Watch가 추가되며 확인하고 싶은 코드 디버깅이 가능합니다.

## Byebug
#### Byebug란?  
Byebug는 Ruby2 용 디버거입니다.
실행을 멈추고 디버깅을 시작하려는 위치에 'byebug' 코드를 추가하여 디버깅을 시작할 수 있습니다.

> #### 실행코드
{% highlight ruby %}
  def create
    @product = Product.new(product_params)

    byebug

    respond_to do |format|
      if @product.save
        format.html { redirect_to @product, notice: 'Product was successfully created.' }
        format.json { render :show, status: :created, location: @product }
      else
        format.html { render :new }
        format.json { render json: @product.errors, status: :unprocessable_entity }
      end
    end
  end
{% endhighlight %}

> #### 결과이미지
![RubyMine Debugger 예시 이미지](/assets/images/2-8.png){: width="100%", :class=mfp-img}
- Byebug는 중지 될 때마다 현재 줄을 중심으로 10 줄의 코드를 자동으로 나열합니다.

> #### 유용한 명령어
- where (backtrace) : byebug 실행시점에 오기까지의 call stack을 확인 할 수 있습니다. 현재 시점은 0번부터 시작되며 숫자가 커질수록 이전에 실행된 내용입니다.
- frame n : call stack n번 지점으로 debug포인트가 이동됩니다.
- up n / down n : debug포인터를 call stack n개 씩 이동할 때 사용됩니다. down일수록 현재 시점에 가깝습니다.
- l- (list-) : byebug 실행시 출력된 위치에서 10줄 위의 스크립트가 출력됩니다.
- l= (list=) : 현재 멈춰있는 byebug 위치의 스크립트가 출력됩니다.
- step : 스크립트를 한줄씩 실행합니다. (제일중요)
- eval, display : 변수값을 확인해 볼때 사용됩니다.
- q : byebug를 종료합니다. (q! : 강제종료)


