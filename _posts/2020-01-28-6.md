---
published: true
layout: single
title: "JUnit 테스트 코드 작성 방법"
comments: true 
categories:
  - Spring
tags:
  - JUnit
---

*본문은 백기선 강사님의 '더 자바, 애플리케이션을 테스트하는 다양한 방법' 강의를 듣고 정리한 내용입니다.*


## JUnit5
- springboot 2.2부터는 spring boot stater가 제공하는 junit 의존성이 5.으로 업그레이드 되었습니다.
- junit5부터는 reflection을 사용하기 때문에 public을 붙여주지 않아도 됩니다.
- springboot로 프로젝트를 만들지 않은경우에는 junit.jupiter 의존성만 넣어주면 됩니다.
- @BeforeAll, @AfterAll : 반드시 static 을 사용해야 하며 private은 안되고 return은 없어야 합니다.
  - @BeforeAll : 모든 클래스가 실행되기 이전에 딱 한번만 호출이됨
  - @AfterAll : 모든 클래스가 실행된 이후에 딱 한번만 호출이됨
- @BeforeEach, @AfterEach : static일 필요는 없음
    - 각각의 테스트를 실행하기 이전과 이후에 실행이 됨
- @Disabled : 테스트를 실행시키지 않을 경우 추가하는 annotation 입니다.


## JUnit5 테스트 이름 표시하기
#### @DisplayNameGeneration()
  - class와 method 앞에 사용할 수 있으며, class앞에 붙일경우 모든 method에 적용이 됩니다.
  - 어떤식으로 display 명을 생성할 것인지 전략에 해당하는 구현체를 인자로 받습니다.
  - ex) @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)  

#### @DisplayName(“원하는 테스트명”)
  - 원하는 테스트 명으로 출력됩니다.

## JUnit5 Assertion
### assertion이란? 
실제 테스트에서 검증하고자 하는 내용을 확인해 볼 수 있음
#### assertEquals(기대하는값, 실제값, 실패시 출력 메세지)
- 실패시 출력메세지에는 java8에 나오는 ramda식이 들어갈 수도 있음
{% highlight Java %}
  assertEquals(StudyStatus.DRAFT, study.getStatus(), new Supplier<String>() {
    System.out.println("assertEquals test");
  });
  // new Supplier가 java8 부터는 ramda식으로 바꿀 수 있음
{% endhighlight %}
- 연산을 해야하는 출력메세지를 그냥 문자열로 만들 경우에는 테스트의 성공 실패 여부와 관계없이 문자열 연산을 실행함
- ramda식으로 작성할 경우 최소한으로 연산 실행을 함으로써 성능적으로 유리하게 됩니다.

#### assertAll
- assert를 여러개 수행한경우 상위 테스트가 실패하면 다음 테스트로 넘어가지 않습니다. 이때 한번에 모든 테스트를 실행하는 방법으로 assertAll을 사용할 수 있습니다.
- 사용법 : assertAll 함수내에 ramda식으로 assert식을 묶어줍니다.

#### assertThrows(발생할 에러타입, 어떤코드를 실행할때)
- exception이 발생하는지 확인하는 방법입니다.

#### assertTimeout(예상실행시간, 실행시킬 코드)
- 실행시킬 코드의 시간이 예상시간 보다 큰경우 에러를 출력한다.

#### assertTimeoutPreemptively
- assertTimeout는 실행시킬 코드의 실행이 끝날때까지 기다렸다가 반환을 하는 반면에 assertTimeoutPreemptively는 코드의 예상시간이 끝나면 반환해줍니다.
- Tread Local을 사용하는 코드를 실행시키는 경우 예상치 못한 문제가 발생할 수 있으므로 assertTimeout의 사용을 추천합니다.


springbootStarter사용시 assertion과 동일한 기능을 수행하는 assertJ와 hamerest를 사용할 수 있습니다.

## 조건에 따라 테스트하기
JUnit jupiter Assumptions 을 import해 사용 가능합니다.
#### function
- assumeTrue : 조건이 true인 경우에만 그다음에 오는 테스트 코드 실행합니다.
- AssumingThat : 주어진 조건이 만족하는 경우 내부의 코드를 실행시킨다
  - AssumingThat("LOCAL".equalsIgnoreCase(test_env),()->{조건만족시 테스트하고 싶은 코드});  

#### Annotation
- @EnabledOnOs(OS.MAC) : 메소드 위에 선언하는 어노테이션으로써 os가mac인경우 메소드 실행 합니다.
    * @EnabledOnOs({OS.MAC,OS.LINUX}) : 배열로 조건 설정 
- @DisabledOnOs(OS.MAC) : os가mac이 아닌 경우 메소드 실행 합니다.
- @EnabledOnJre({JRE.JAVA_8, JR.JAVA_9}) : 특정 자바 버전에서 테스트 할때 사용
- @EnabledOnJre(JRE.OTHER) : 위에서 선언한 버전 외의 버전일 때 해당 테스트가 실행됩니다.
- @EnabledIfEnvironmentVariable(named="TEST_ENV", matches="LOCAL") : 환경변수가 LOCAL과 매치가 될때 해당 테스트를 실행시킵니다.

## JUnit5 태깅과 필터링
### 테스트 태깅이란? 
테스트를 여러개 만들었을때 해당 테스트를 그룹화 하는것을 의미합니다. 
- 모듈별, 또는 단위테스트인지 통합테스트인지 오래걸리는지 짧게 걸리는지에 따라 원하는 태그를 붙입니다.
- 태깅을 원하는 method 위에 @Tag("태깅명") 으로 선언합니다.

### 태깅에 따라 테스트를 실행하는 방법
#### Intellij에서 필터링
- Edit configureation->Test kind->Tag expresstion에 태그명을 넣으면 태그명에 해당되는 테스트만 실행됩니다.

#### 빌드할때
- Maven설정에서 Profiles를 지정하면 profile마다 다른설정을 해줄 수 있습니다.
- Fast 태그가 붙어있는 테스트를 default로 실행하고, ci로 태깅 지정 시 전부다 실행 하는 설정
{% highlight Java %}
  <profiles>
    <profile>
        <id>default</id>
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
        <build>
            <plugins>
                <plugin>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <configuration>
                        <groups>fast</groups>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    </profile>
    <profile>
        <id>ci</id>
        <build>
            <plugins>
                <plugin>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <configuration>
                        <groups>fast | slow</groups>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    </profile>
  </profiles>
{% endhighlight %}
위와같이 Profile 설정 후 [./mvnw test -P ci] 명령어를 통해 ci라는 profile을 실행합니다.

## JUnit5 테스트 순서
- 기본적으로 테스트는 작성된 순서대로 실행이 되지만 절대 의도없이 실행되는 순서에 의존을 하면 안됩니다.
- 기본적으로 테스트 단위 별로는 서로의 테스트에 영향을 주지 않습니다.  

#### 하지만 상태정보와 데이터를 공유한 순차적인 테스트가 필요하다면? 
- @TestInstance annotation을 사용해 인스턴스를 method 마다 새로만드는 게 아니라 하나로 공유 합니다.(상태정보와 데이터 공유한 경우에만 선택)
- @TestMethodOrder() MethodOrderer의 구현체를 넘겨주어 method간의 순서를 정해 줍니다.
- 순서를 지정하고 싶은 method에 @Order(순서) annotation으로 순서를 지정해 줍니다.


## JUnit5 junit-platform.properties
설정파일 생성을 통해 JUnit을 설정 할 수 있습니다.
1. test/resources/junit-platform.properties 파일 생성
2. Intellij에서 test resources directory로 설정해 주어야 합니다.
  - File > Project Structure 에서 설정 가능 합니다.
  - 아래 이미지와 같이 test/resources/junit-platform.properties를 Test Resources로 설정해 줍니다.
  ![test resources directory 설정 이미지](/assets/images/2020-01-28_1.png){: width="100%"}
    {% highlight Java %}
    //테스트 인스턴스 라이프사이클 설정
    junit.jupiter.testinstance.lifecycle.default = per_class

    //확장팩 자동 감지 기능
    junit.jupiter.extensions.autodetection.enabled = true

    //@Disabled 무시하고 실행하기
    junit.jupiter.conditions.deactivate = org.junit.*DisabledCondition

    //테스트 이름 표기 전략 설정
    junit.jupiter.displayname.generator.default = \
        org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
    {% endhighlight %}


## JUnit 테스트 관련 단축키
- 테스트를 실행 : ctrl+shift+r
    - 특정 method에 커서를 놓고 실행하면 해당 method만 실행되고, 아니면 해당 class에 모든 test가 실행됩니다.
- 테스트를 생성 : cmd+shift+t
- quick fix : alt+enter
- create file : option+enter
- 메소드의 필요한 파라미터 정보 : command + p
- 메소드 추출 : alt+command+m

