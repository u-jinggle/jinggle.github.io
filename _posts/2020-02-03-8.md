---
published: true
layout: single
title: "IOC 컨테이너와 Bean"
comments: true 
categories:
  - Spring
sidebar:
  nav: "sidebar-sample"
---

#### IOC(Inversion Of Control)이란?  
의존관계에 해당하는 객체를 직접 생성해서 사용하는게 아니라 생성자를 통해 주입을 받아 사용하는 방법을 뜻한다

#### Bean이란?  
IOC컨테이너가 관리하는 객체를 의미한다

#### BeanFactory  
Spring IOC Container의 최상위 있는 Interface

[BeeanFactory 공식 문서](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html)

#### Bean으로 등록을 하는 이유  
- 의존성 주입을 하기 위해서
- single tone scope로 객체를 관리하고 싶을때 (->prototype에 비해 성능 우세)
- Lifecycle Interface를 사용가능

#### ApplicationContext  
BeanFactory에 비해 다양한 기능을 가지고 있는 Interface

## @Component와 컴포넌트 스캔
### ComponentScan이란?
- ComponentScan이라는 Annotation은 Spring 3.1부터 도입됨
- ComponentScan의 가장 중요한 설정은 basePackages인데, 이것의 type safe한 방법이 basePackageClasses이다  
- basePackageClasses에 전달된 class를 기준으로 ComponentScan이 시작된다   
- 따라서 ComponentScan을 붙이고 있는 Configuration부터 ComponentScan이 시작된다

### ComponentScan이 되는 Annotaion
- @Service
- @Controller
- @Repository
- @Configuration

### ComponentScan은 excludeFilters를 통해 제외할 옵션을 지정해 줄 수 있다
### ComponentScan의 범위
ComponentScan이 선언된 Class와 동일한 Package의 Class전부와 하위 Package의 모든 클래스가 포함됨

### Functional을 사용한 bean등록 방법
- Singleton scope의 bean들은 초기에 다 생성을 하기 때문에 초기 구동시간이 지연될 수 있다
- Functional을 사용한 bean등록은 Reflextion또는 proxy를 만드는 기법을 사용하지 않기 때문에 성능(구동시간)에 영향을 주지 않는다

#### 외부 Package에 있는 myService를 Functional을 사용하여 Bean으로 등록하기
{% highlight Java %}
@SpringBootApplication
public class DemoApplication {
    @Autowired
    MyService myService;

    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(DemoApplication.class);
        app.addInitializers(new ApplicationContextInitializer<GenericApplicationContext> ctx -> ctx.registerBean(MyService.class));
        app.run(args);
    }

}
{% endhighlight %}  
- 사용시점 : ComponentScan을 대체하기 보다는 @bean 으로 직접 등록하는 경우 Functional을 사용한 bean등록 방법으로 대체 할 수 있다

## bean의 Scope
### Scope
#### Singleton Scope  
application 전반에 걸쳐 해당 bean의 instance가 오직 한개만 생성됨
#### Proto Type
해당 instance를 매번 새롭게 생성    

- @Scope("prototype")을 추가해주면 Proto Type으로 설정이 가능
- 문제 : Singletone Scope의 Bean에서 Proto Type의 Bean을 참조할때, 매번 생성되는 Proto Type의 instance를 최조 한번만 Singletone으로 등록하기 때문에 문제 발생
- 해결 : @Scope의 proxyMode 옵션을 사용하여 해당 class 또는 interface를 Proxy로 감싸주어 선언해주면 Singletone Scope에서 참조하는 경우에도 해당 instance가 생성될 때마다 재참조를 수행하게 된다

#### Singletone Scope에서 Proto Type의 객체를 참조하는 경우 문제 해결 방법
{% highlight Java %}
@Component @Scope(value = "prototype", proxyMode= ScopedProxyMode.TARGET_CLASS)
    public class Proto {
    @Autowired
    Single single;
}
{% endhighlight %}  

- Singleton Scope 사용시 주의사항 : 하나의 instance를 공유하므로 반드시 Thread Safe한 방법으로 진행해야 한다


## Profile이란?
환경별로 사용할 Bean들의 묶음을 의미한다. 각각의 환경별로 Bean을 구분하거나, 특정한 환경에서만 해당 Bean을 등록해야할 경우 Profile을 사용해 구분지을 수 있다
- Application Context의 evvironment기능을 사용해 profile을 구성 할 수 있다  

#### EnvironmentCapable을 통해 profile정보 확인하기
{% highlight Java %}
@Component
public class AppRunner implements ApplicationRunner {
    @Autowired
    ApplicationContext ctx;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        Environment environment = ctx.getEnvironment();
        System.out.println("Active profile : "+ Arrays.toString(environment.getActiveProfiles()));
        System.out.println("Default profile : "+Arrays.toString(environment.getDefaultProfiles()));
    }
}
{% endhighlight %}  

#### Profile이 test인 경우에만 적용될 Configuration설정
{% highlight Java %}
@Configuration
@Profile("test")
public class TestConfiguration {
    public BookRepository bookRepository(){
        return new TestBookRepository();
    }

}
{% endhighlight %}  

#### profile 실행 환경 설정하는 방법1
![profile 실행 환경 설정 예시이미지1](/assets/images/2020-02-17-1.png){: width="100%"} 

#### profile 실행 환경 설정하는 방법2
![profile 실행 환경 설정 예시이미지2](/assets/images/2020-02-17-2.png){: width="100%"} 

- Component Scan으로 등록되는 bean의 경우에도 @Profile(환경명)을 통해 profile선언이 가능하다

~~~
@Profile(환경명) : 해당 환경에서만 Bean등록
@Profile(!환경명) : 해당 환경이 아닌경우에만 Bean등록
~~~

## Property
Application에서 제공하는 여러가지 Key-value형태의 property에 접근하는 기능으로 계층형으로 제공된다  

#### property 설정하는 방법1
![property 설정 예시이미지1](/assets/images/2020-02-17-3.png){: width="100%"} 

#### getProperty를 통해 property확인
{% highlight Java %}
@Component
public class AppRunner implements ApplicationRunner {

    @Autowired
    ApplicationContext ctx;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        Environment environment = ctx.getEnvironment();
        System.out.println(environment.getProperty("app.name"));
    }
}
{% endhighlight %}  


#### 별도의 파일로 Property설정
Resources/app.property
{% highlight Java %}
app.about=spring
{% endhighlight %}  

#### Resources/app.property 파일 읽어와서 property사용예제
{% highlight Java %}
@SpringBootApplication
@PropertySource("classpath:/app.properties")
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
{% endhighlight %}  



